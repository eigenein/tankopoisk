#!/usr/bin/env python3
# coding: utf-8

import concurrent.futures
import heapq
import itertools
import logging
import operator
import random
import sys
import threading
import time

import click
import requests

import structs


@click.command()
@click.option("--max-id", default=40000000, help="Maximum account ID.", metavar="<id>", show_default=True)
@click.option("--thread-count", default=16, help="thread count", metavar="<n>", show_default=True)
@click.option("--app-id", default="demo", help="application ID", metavar="<id>", show_default=True)
@click.argument("output", metavar="<output>", type=click.File("wb"))
def main(max_id, thread_count, app_id, output):
    "Get account statistics from Wargaming Public API."

    logging.basicConfig(
        format="%(asctime)s (%(module)s) [%(threadName)10s] %(levelname)s %(message)s",
        level=logging.INFO, stream=sys.stderr,
    )

    logging.info("Writing header.")
    output.write(structs.magic)

    logging.info("Starting.")
    dumper = Dumper(app_id, output)
    with concurrent.futures.ThreadPoolExecutor(max_workers=thread_count) as executor:
        executor.map(dumper.execute, chop(range(1, max_id), 100))

    logging.info("Final dump.")
    dumper.dump()

    logging.info("Finished.")


class LocalSession(threading.local):
    "Provider thread-local Session instance."

    def __init__(self):
        self.session = requests.Session()


class WargamingApiError(Exception):
    "Wargaming API error."

    def __init__(self, code, message, **kwargs):
        super(WargamingApiError, self).__init__(code, message)
        self.code = code
        self.message = message


class Dumper:

    local_session = LocalSession()

    def __init__(self, app_id, output):
        self.app_id = app_id
        self.output = output
        self.expected_id = 1
        self.account_heap = []
        self.start_time = time.time()
        self.account_count = 0
        self.tank_count = 0

    def execute(self, account_id):
        for attempt in itertools.count():
            try:
                return self.execute_unsafe(account_id)
            except WargamingApiError as e:
                logging.warning("API error: %s attempt: %s.", e.message, attempt)
                base_time = 2.0 ** attempt
                time.sleep(random.uniform(base_time, base_time * 2.0))
            except:
                logging.critical("Error.", exc_info=True)

    def execute_unsafe(self, account_id):
        response = self.local_session.session.get(
            "http://api.worldoftanks.ru/wot/account/tanks/",
            params={
                "application_id": self.app_id,
                "account_id": ",".join(map(str, account_id)),
                "fields": "statistics,tank_id",
            },
        )
        response.raise_for_status()
        result = response.json()
        if result["status"] != "ok":
            raise WargamingApiError(**result["error"])
        for account_id, tanks in result["data"].items():
            heapq.heappush(self.account_heap, (int(account_id), tanks))
        self.dump()

    def dump(self):
        "Dumps account heap if possible."
        while self.account_heap and (self.account_heap[0][0] == self.expected_id):
            account_id, tanks = heapq.heappop(self.account_heap)
            self.expected_id = account_id + 1
            if tanks is None:
                continue
            tanks = sorted(tanks, key=operator.itemgetter("tank_id"))
            for tank in tanks:
                self.output.write(structs.entry.pack(
                    account_id,
                    tank["tank_id"],
                    tank["statistics"]["battles"],
                    tank["statistics"]["wins"],
                ))
                self.tank_count += 1
            self.account_count += 1

        aps = (self.expected_id + len(self.account_heap)) / (time.time() - self.start_time)
        logging.info(
            "#%s count: %s tanks: %s aps: %.1f apd: %.0f heap: %s",
            self.expected_id, self.account_count, self.tank_count, aps, aps * 86400.0, len(self.account_heap),
        )


def chop(iterable, length):
    iterable = iter(iterable)
    while True:
        chunk = list(itertools.islice(iterable, length))
        if not chunk:
            return
        yield chunk


if __name__ == "__main__":
    main()
